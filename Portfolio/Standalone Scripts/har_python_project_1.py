# -*- coding: utf-8 -*-
"""HAR Python Project 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WDTtntYv4iZkFblcvH_cDalIOe8eOLzZ

# Brief for 3 friends in computer science to develop python project together

## **Project Title:** Personal Finance Tracker

### **Description:** Create a Python application that allows users to track their income and expenses, set budgets, and visualize their spending habits.

*Features:*

*   **User Authentication:** Allow users to create accounts and securely log in.

*   **Income and Expense Tracking:** Enable users to input their income and expenses, categorize transactions, and add notes.

*   **Optional Features:** Consider adding features like exporting data, setting financial goals, or integrating with bank accounts (if you're comfortable with APIs and security).

*   **Budgeting:** Allow users to set budgets for different categories (e.g., food, housing, entertainment) and track their progress.

*  **Data Visualization:** Generate charts and graphs to visualize spending patterns over time, compare income and expenses, and track budget adherence

*   **Reporting:** Generate reports summarizing income, expenses, and budget adherence for specific periods.

## Account Class
"""

!pip install passlib
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class Account:
  def __init__(self, username, password, accountType):
    self.username = username
    self.password = self.encrypt_password(password)
    self.logged_in = False
    self.accountType = accountType
    print("Welcome to Finance Fulcrum.")

  def Login(self, username, password):
    if username == self.username and self.check_encrypted_password(password, self.password):
      print("You are now logged in.")
      self.logged_in = True
    else:
      print("Incorrect information typed")
      self.logged_in = False
    return self.logged_in

  def encrypt_password(self, password):
    return pwd_context.hash(password)

  def check_encrypted_password(self, password, hashed):
    return pwd_context.verify(password, hashed)

  def change_password(self, old_password, new_password):
    if self.check_encrypted_password(old_password, self.password):
      self.password = self.encrypt_password(new_password)
      print("Password has been changed.")
      return True
    else:
      print("Incorrect password.")
      return False

  def logout(self):
    self.logged_in = False
    print("You have been logged out.")

  def get_account_type(self):
    return self.accountType

  def set_account_type(self, accountType):
    self.accountType = accountType

"""username = "Bob"
password = 102978932
account = Account(username, password)

user_username = input("Enter username: ")
user_password = int(input("Enter a password (must be in digits): "))
account.Login(user_username, user_password)"""

"""## Accounts class (mini database for all accounts)"""

class Accounts:
  def __init__(self):
    self.accounts = []

  def add_account(self, account):
    self.accounts.append(account)

  def get_account(self, username):
    for account in self.accounts:
      if account.username == username:
        return account
    return None

  def remove_account(self, username):
    for account in self.accounts:
      if account.username == username:
        self.accounts.remove(account)
        return True
    return False

  def update_password(self, username, old_password, new_password):
    for account in self.accounts:
      if account.username == username:
        if account.change_password(old_password, new_password):
          return True
    return False

  def get_all_accounts(self):
    return self.accounts

  def get_account_count(self):
    return len(self.accounts)

  def get_account_names(self):
    return [account.username for account in self.accounts]

  def get_account_passwords(self):
    return [account.password for account in self.accounts]

  def get_account_login_status(self):
    return [account.logged_in for account in self.accounts]

  def get_account_types(self):
    return [account.accountType for account in self.accounts]

  def get_account_info(self):
    return [(account.username, account.password, account.logged_in, account.accountType) for account in self.accounts]

  def save_accounts(self, filename):
    print("Saving accounts...")
    with open(filename, "w") as f:
      for account in self.accounts:
          f.write(f"{account.username},{account.password},{account.logged_in},{account.accountType}\n")
    print(len(self.accounts), "accounts saved successfully.")

  def load_accounts(self, filename):
    print("Loading accounts...")
    with open(filename, "r") as f:
      for line in f:
        username, password, logged_in, account_type = line.strip().split(",")
        account = Account(username, password, account_type)
        account.logged_in = logged_in
        self.add_account(account)
    print("Accounts loaded successfully.")
    print(len(self.accounts), "accounts loaded.")

  def add_admin_account(self, username, password):
    if username in self.get_account_names():
      account = self.get_account(username)
      if account.check_encrypted_password(password, account.password):
        account.set_account_type("admin")
        print("Admin account updated successfully.")
      else:
        print("Admin account failed to update.")
    else:
      admin_account = Account(username, password, "admin")
      self.accounts.append(admin_account)
      print("Admin account added successfully.")

  def get_admin_account(self):
    for account in self.accounts:
      if account.get_account_type() == "admin":
        return account
    return None

"""## Menu class (all interface related methods)"""

#import the google colab files module that allows file uploads and downloads
from google.colab import files

class Menu:
  def __init__(self):
    self.menuOptions = {1: "1. Create Account", 2: "2. Login to your account", 3: "3. Change your Password", 4: "4. Logout",
                        5: "5. Load accounts (admin)", 6: "6. Search for an account", 7: "7. Add an account (admin)",
                        8: "8. Remove an account (admin)", 9: "9. Update a password (admin)", 10: "10. Save accounts (admin)",
                        11: "11. Finance options", 12: "12. Add admin account (admin)", 13: "13. Exit"}
    self.accounts = Accounts()

  def displayMenu(self):
    print("Welcome to Finance Fulcrum, Below are the main menu options\n")
    for option in self.menuOptions.values():
      print(option)

  def getChoice(self):
    print("\nEnter your choice from the options above: ")
    choice = 0
    while choice not in self.menuOptions.keys():
      try:
        choice = int(input("Enter your choice: "))
      except ValueError:
        print("Invalid input. Please enter a number.")
    return choice

  def createAccount(self):
    print("You have selected: Creating an account")
    username = input("Enter a username: ")
    password = getpass.getpass(prompt="Enter a password in digits only: ")
    account = Account(username, password, "basic")
    self.accounts.add_account(account)
    print("Account created successfully.")

  def loginToAccount(self):
    print("You have selected: Login to your account")
    #Logging into account section (Contains while loop to ensure limited no. of tries)
    attempts = 5
    logged_in = False
    while logged_in == False and attempts > 0:
      print("You have", attempts, "attempts left to login")
      username = input("Enter username: ")
      thisAccount = self.accounts.get_account(username)
      password = getpass.getpass(prompt="Enter a password in digits only: ")
      if thisAccount is not None:
        logged_in = thisAccount.Login(username, password)
      else:
        print("Account not found.")
        create_account = input("Would you like to create an account? (y/n): ")
        if create_account.lower() == "y":
          self.createAccount()
        else:
          print("Returning to main menu...")
        break
      attempts -= 1
    if not logged_in and thisAccount is not None:
      print("Login failed. Account now temporarily locked.")

  def changePassword(self):
    print("You have selected: Change your password")
    username = input("Enter your username: ")
    password = getpass.getpass(prompt="Enter your old password (digits only): ")
    new_password = getpass.getpass(prompt="Enter your new password (digits only): ")
    if self.accounts.update_password(username, password, new_password):
      print("Password changed successfully.")
    else:
      print("Incorrect username or password.")

  def logout(self):
    print("You have selected: Logout")
    username = input("Confirm by entering your username: ")
    account = self.accounts.get_account(username)
    if account is not None:
      account.logout()
    else:
      print("Account not found. Cannot be logged out.")

  def loadAccounts(self):
    print("You have selected: Load accounts")
    filename = input("Enter the filename to load accounts from: ")
    self.accounts.load_accounts(filename)

  def searchForAccount(self):
    print("You have selected: Search for an account")
    username = input("Enter the username of the account to search for: ")
    account = self.accounts.get_account(username)
    if account is not None:
      print("Account found:")
      print("Username:", account.username)
      print("Encrypted Password:", account.password)
      print("Logged in:", account.logged_in)
    else:
      print("Account not found.")

  def addAccount(self):
    print("You have selected: Add an account")
    username = input("Enter the username of the new account: ")
    password = input("Enter the password of the new account: ")
    account = Account(username, password, "basic")
    self.accounts.add_account(account)
    print("Account added successfully.")

  def removeAccount(self):
    print("You have selected: Remove an account")
    username = input("Enter the username of the account to remove: ")
    if self.accounts.remove_account(username):
      print("Account removed successfully.")
    else:
      print("Account not found.")

  def updatePassword(self):
    print("You have selected: Update a password")
    username = input("Enter the username of the account to update: ")
    old_password = getpass.getpass(prompt="Enter the old password (digits only): ")
    new_password = getpass.getpass(prompt="Enter the new password (digits only): ")
    if self.accounts.update_password(username, old_password, new_password):
      print("Password updated successfully.")
    else:
      print("Incorrect username or password.")

  def saveAccounts(self):
    print("You have selected: Save accounts")
    filename = input("Enter the filename to save accounts to: ")
    self.accounts.save_accounts(filename)
    if self.accounts.get_account_count() > 0:
      files.download(filename)
      print("Accounts downloaded successfully!")
    else:
      print("No accounts to download!")

  def openFinanceOptions(self):
    print("You have selected: Finance options")
    financeOptions = FinanceOptions()
    exit = False
    while not exit:
      financeOptions.displayMenu()
      choice = financeOptions.getChoice()
      exit = financeOptions.handleChoice(choice)
      print("\n")

  def addAdminAccount(self):
    print("You have selected: Adding an admin account")
    username = input("Enter the username of the admin account (existing or new): ")
    password = input("Enter the password of the admin account: ")
    self.accounts.add_admin_account(username, password)
    print("Admin account added successfully.")

  def exitProgram(self):
    print("You have selected: Exit")
    print("Thank you for using Finance Fulcrum. Have a great day!")

  def handleChoice(self, choice):
    print()
    match choice:
      case 1:
        self.createAccount()
        return False
      case 2:
        self.loginToAccount()
        return False
      case 3:
        self.changePassword()
        return False
      case 4:
        self.logout()
        return False
      case 5:
        self.loadAccounts()
        return False
      case 6:
        self.searchForAccount()
        return False
      case 7:
        self.addAccount()
        return False
      case 8:
        self.removeAccount()
        return False
      case 9:
        self.updatePassword()
        return False
      case 10:
        self.saveAccounts()
        return False
      case 11:
        self.openFinanceOptions()
        return False
      case 12:j
        self.addAdminAccount()
        return False
      case 13:
        self.exitProgram()
        return True
      case _:
        print("Invalid choice. Please try again.")
        return False

"""## Finance Options Class"""

class Stack:
  def __init__(self, maxsize):
    self.maxsize = maxsize
    self.array = [""]*self.maxsize
    self.pointer = -1
    self.used_positions = 0

  def push(self,item):
    full = self.isFull()
    if full:
      print("Not available")
    else:
      self.array[self.pointer+1] = item
      self.pointer = self.pointer+1
      self.used_positions = self.used_positions + 1

  def pop(self):
    empty = self.isEmpty()
    if empty:
      print("The stack is empty, cannot dequeue", self.array[self.pointer])
    else:
      chore = self.array[self.pointer]
      self.pointer = self.pointer - 1
      self.used_positions = self.used_positions - 1
      return chore

  def isFull(self):
    if self.used_positions == self.maxsize:
      return True
    else:
      return False

  def isEmpty(self):
    if self.used_positions == 0:
      return True
    else:
      return False

  def peek(self):
    return self.array[self.pointer]

  def show_all(self):
    self.list = []
    for x in range (0, self.pointer+1):
      self.list.append(self.array[x])
    return self.list

class FinanceOptions:
  def __init__(self):
    self.__TotalIncome = 0
    self.__TotalExpenses = 0
    self.__balance = self.__TotalIncome - self.__TotalExpenses
    self.BrokieStatus = None
    self.FinanceHistory = Stack(100)
    self.ReportGenerator = Reporting()
    self.NotesManager = TransactionNotes()
    self.options = {1: "1. Input income", 2: "2. Input expenses", 3: "3. View Balance", 4: "4. View total income",
                    5: "5. View total expenses", 6: "6. View total finance history", 7: "7. Generate Report", 8: "Go Back"}

  def displayMenu(self):
    print("Below are the finance menu options\n")
    for option in self.options.values():
      print(option)

  def getChoice(self):
    print("\nEnter your choice from the options above: ")
    choice = 0
    while choice not in self.options.keys():
      try:
        choice = int(input("Enter your choice: "))
      except ValueError:
        print("Invalid input. Please enter a number.")
    return choice

  def IncomeInput(self, income):
    self.__TotalIncome += income
    self.FinanceHistory.push(+income)

  def ExpensesInput(self, expenses):
    self.__TotalExpenses += expenses
    self.FinanceHistory.push(-expenses)

  def IncomeOutput(self):
    return self.__TotalIncome

  def ExpensesOutput(self):
    return self.__TotalExpenses

  def SeeFinanceHistory(self):
    financeHistory = self.FinanceHistory.show_all()
    #print the finance history one by one, put a comma between if both positive or both negative and new line if different
    for x in range(0, len(financeHistory)-1):
      if financeHistory[x] > 0 and financeHistory[x+1] > 0:
        print(financeHistory[x], ", ", end="")
      elif financeHistory[x] < 0 and financeHistory[x+1] < 0:
        print(financeHistory[x], ", ", end="")
      else:
        print(financeHistory[x])
    return financeHistory

  def TotalBalanceCalc(self):
    self.__balance = self.__TotalIncome - self.__TotalExpenses
    return self.__balance

  def BrokieMeter(self):
    if self.__balance < 1000000:
      self.BrokieStatus = True
    else:
      self.BrokieStatus = False
    return self.BrokieStatus

  def GenerateReport(self):
    print("Generating report...")
    start_date = input("First enter the start date (dd/mm/yyyy): ")
    end_date = input("Also enter the end date for the report (dd/mm/yyyy): ")
    totalIncome, totalExpenses, datedTransactions = self.ReportGenerator.generateReport(start_date, end_date, self.FinanceHistory)
    print("Report generated")
    print("Total income:", totalIncome)
    print("Total expenses:", totalExpenses)
    for transaction in datedTransactions:
      print("Date:",transaction.date)
      print("Amount:",transaction.amount)
      print("Category:",transaction.category)
      if transaction.notes:
        print("Notes:",transaction.notes)
      print()

  def handleChoice(self, choice):
    print()
    match choice:
      case 1:
        income = int(input("Enter income: "))
        date = input("Also enter the date: ")
        self.ReportGenerator.setDate(date)
        self.IncomeInput(income)
        addNote = input("Would you like to add a note? (y/n): ")
        if addNote.lower() == "y":
          self.incomeID = self.ReportGenerator.getID(self.FinanceHistory.used_positions - 1)
          self.NotesManager.addNote(self.incomeID)
        return False
      case 2:
        expenses = int(input("Enter expenses: "))
        date = input("Also enter the date: ")
        self.ReportGenerator.setDate(date)
        self.ExpensesInput(expenses)
        addNote = input("Would you like to add a note? (y/n): ")
        if addNote.lower() == "y":
          self.expenseID = self.ReportGenerator.getID(self.FinanceHistory.used_positions - 1)
          self.NotesManager.addNote(self.expenseID)
        return False
      case 3:
        balance = self.TotalBalanceCalc()
        print("Your current balance is: " + str(balance))
        return False
      case 4:
        total_income = self.IncomeOutput()
        print("Your total income is: " + str(total_income))
        return False
      case 5:
        total_expenses = self.ExpensesOutput()
        print("Your total expenses is: " + str(total_expenses))
        return False
      case 6:
        self.SeeFinanceHistory()
        return False
      case 7:
        self.GenerateReport()
        return False
      case 8:
        print("Returning to main menu...")
        return True
      case _:
        print("Invalid choice. Please try again.")
        return False



"""## Budgeting class"""

class Category:
    def __init__(self, category, budget):
        self.category = category
        self.progress = 0
        self.budget = budget

    def __str__(self):
        return self.category

    def setCategory(self, category):
        self.category = category

    def setBudget(self, budget):
        self.budget = budget

    def setProgress(self, progress):
        self.progress = progress

    def getProgress(self):
        return self.progress

    def getBudget(self):
        return self.budget

    def calculateProgress(self, expense):
        self.progress += (expense / self.budget) * 100
        return round(self.progress, 2)

class Budgeting(object):
    def __init__(self, categoryNames, budgets):
        self.categories = []
        for category in categoryNames:
            self.categories.append(Category(category, budgets[categoryNames.index(category)]))

    def categoryMenu(self):
        print("1. Display Categories \n2. Add Category \n3. Delete Category \nPlease select your choice!")
        choice = input()
        self.__checkChoice(choice)

    def __checkChoice(self, choice):
        while choice != "1" and choice != "2" and choice != "3":
            choice = input("Please select a valid choice! \n")
        else:
            if choice == "1":
                self.__displayCategories()
                self.categoryMenu()
            elif choice == "2":
                self.__addCategory()
            elif choice == "3":
                self.__deleteCategory()

    def __displayCategories(self):
        print("\nHere is the current list of budget categories entered below:\n")
        for category in self.categories:
            print(f"{category}, Budget: {category.getBudget()}, Progress: {category.getProgress()}%")
        print("\n")
        #self.categoryMenu()

    def progressCategory(self, categoryName, expense):
        for category in self.categories:
            if str(category) == categoryName:
              category.calculateProgress(expense)

    def __addCategory(self):
        category = input("\nEnter budget category: ")
        budget = int(input("Enter budget: "))
        thisCategory = Category(category, budget)
        self.categories.append(thisCategory)
        print(f"\nThe category {str(thisCategory)}, has been added to the list with a budget of {thisCategory.getBudget()}!\n")
        self.categoryMenu()

    def __deleteCategory(self):
        if len(self.categories) < 1:
            print("\nPlease add a category first!\n")
            self.categoryMenu()
        while True:
            try:
                self.__displayCategories()
                choice = input("Please enter a category to delete from the list: ")
                for category in self.categories:
                    if str(category) == choice:
                        self.categories.remove(category)
                        print(f"\nThe category {str(category)} has been removed from the list!\n")
                        break
            except:
                print("\nInvalid category entered!")
            self.categoryMenu()

budgeting = Budgeting([],[])
budgeting.categoryMenu()

"""## Reporting Class"""

#Reporting

from datetime import datetime

class Reporting(): #ID = hastag with 5 digit number after it (e.g #71692)
  def __init__(self):
    self.ID_LIST = [] #1 to 1 mapping with finance history
    self.DATES_ID_MAPPING = {} #Mapping of IDs and dates, IDs as keys, and dates as values

  def setDate(self, transactionDate):
    self.ID_LIST_length = len(self.ID_LIST)
    if self.ID_LIST_length <= 0: #This case is for when the list is empty. <= is used just in case a fly from Rayhaan's room or a moai decide to hack the system using the quantum uncertainty principle and make the list length = -1
      self.NEW_ID = '#00000' #Default starting ID with the list
      self.ID_LIST.append(self.NEW_ID)
      self.DATES_ID_MAPPING[self.NEW_ID] = str(transactionDate)
    else: #This is for every other case possible other than if the list is empty
      self.last_item = self.ID_LIST[self.ID_LIST_length-1]
      self.last_item_number = str(self.last_item[1:6]) #This is used to remove the hashtag from the variable so that it can be used as an integer later on.

      #This section below is designed to make sure any 0 before a number other than 0 within the new ID is kept within the ID and not automatically removed by python.
      #When previous testing was done, python was adamant on removing every 0 before a digit from 1-10 appeared within the ID. This meant that instead of appending '#00010' it would append '#10' to the ID LIST
      self.number_is_zero = True
      self.number_index = 0
      self.number_length = len(self.last_item_number)
      self.digit_list = []
      #Goes through the list, adding each digit to a digit list until it encounters a digit other than 0
      #where it then terminates the while loop.
      while self.number_is_zero == True and len(self.digit_list) < len(self.last_item_number):
        self.digit = self.last_item_number[self.number_index]
        if self.digit != '0':
          self.number_is_zero = False
          self.nonZero_number_index = self.number_index #When a digit from 1-9 is found, this specific number index is the first number index where the digit is not 0, so therefore every 0 before it should be counted and
          #added after the hash when generating the ID. Therefore this number index is special.
        else:
          self.digit_list.append(self.digit) #If a digit other than 0 is found there is no need to add it to the list.
          self.nonZero_number_index = 0
        self.number_index += 1

      if self.nonZero_number_index == 0 and self.last_item == '#00000': #Special case if statement for generating the id '#00001'
        self.NEW_ID = str("#") + str('0000') + str(int(self.last_item_number)+1)
      else: #Case for generating all other ID
        self.NEW_ID = str("#") + str('0'*self.nonZero_number_index) + str(int(self.last_item_number)+1)

      self.ID_LIST.append(self.NEW_ID)
      self.DATES_ID_MAPPING[self.NEW_ID] = str(transactionDate)

  def getDate(self, transactionID):
    return self.DATES_ID_MAPPING[transactionID]

  def getID(self, index):
    return self.ID_LIST[index]

  def generateReport(self, startDate, endDate, financeHistory):
    self.datedTransactions = []
    self.transaction_list = financeHistory.show_all()
    for key, value in self.DATES_ID_MAPPING.items():
      self.date = self.getDate[key]
      #I need to match the indexes of transaction_list and either the DATES_ID_MAPPING or the ID_LIST


class Transaction():
  def __init__(self, date, amount, category, notes):
    self.date = date
    self.amount = amount
    self.category = category
    self.notes = notes

"""## Transaction Notes Class"""

class TransactionNotes(object):
    def __init__(self):
        self.notes = []

    def addNote(self, transactionID):
        note = input("\nCreate a new note here for the current transaction: ")
        self.notes.append((transactionID, note))
        print("\nThe note has been created!\n")

    def __displayNotes(self):
      counter = 1
      for note in self.notes:
        transactionPart = note[0]
        notePart = note[1]
        print(f"{counter}. Transaction ID: {transactionPart}, Note: {notePart}")

    def deleteNote(self):
      if len(self.notes) < 1:
        print("\nPlease make a note first!\n")
        self.__displayNotes()
        print("\nPlease delete a note from the list (1 -",len(self.notes),"): ")
        while True:
          try:
            choice = int(input("Enter your choice: "))
            if 1 <= choice <= len(self.notes):
              break
            else:
              print("\nInvalid input. Please enter a number between 1 and",len(self.notes),".\n")
              self.__displayNotes()
              print("\nPlease delete a note from the list (0 -",len(self.notes),"): ")
          except ValueError:
            print("\nInvalid input. Please enter a number.\n")
            self.__displayNotes()
            print("\nPlease delete a note from the list (0 -",len(self.notes),"): ")
        self.notes.pop(choice-1)
        print("\nThe note has been deleted!\n")

      def returnNotes(self):
        return self.notes

      def updateNote(self, transactionID):
        if len(self.notes) < 1:
          print("\nPlease make a note first!\n")
        else:
          print("Note with transaction ID", transactionID, "will be updated!")
          for note in self.notes:
            if note[0] == transactionID:
              print("\nThe note is currently:",note[1])
              newNote = input("Enter the updated note: ")
              note[1] = newNote
              print("Note updated!\n")

      def updateNotes(self, newNotes):
        self.notes = newNotes

      def hasNotes(self, transactionID):
        for note in self.notes:
          if note[0] == transactionID:
            return True
        return False

transactionNotes = TransactionNotes()

"""## Unit Tests"""

#Account test 1 (do not delete)
from time import sleep

print("Create an account first!\n")
username = input("Enter a new username: ")
password = getpass.getpass(prompt="Enter a password in digits only: ")
account = Account(username, password, "basic")

sleep(5)
print("\nNow login!\n")

user_username = input("Now enter your username to login: ")
user_password = getpass.getpass(prompt="Enter your password (digits only): ")
account.Login(user_username, user_password)

#Account Test 2 (WIP)- Account Start Loop (Logging in & Account Created)
from time import sleep

#Creating account section
account_Created = False
logged_in = False

print("You have selected: Creating an account")
username = input("Enter a username: ")
password = getpass.getpass(prompt="Enter a password in digits only: ")
account = Account(username, password, "basic")
account_Created = True

#Logging into account section (Contains for loop to ensure limited no. of tries)
attempts = 5
while logged_in == False and attempts > 0:
  print("You have", attempts, "attempts left to login")
  sleep(0.7)
  username = input("Enter username: ")
  password = getpass.getpass(prompt="Enter your password (digits only): ")
  logged_in = account.Login(username, password)
  attempts -= 1

"""### Main unit test"""

#Accounts test + menu test (Unit test #3 - written by Hasan)
import getpass
from time import sleep

menu = Menu()
exit = False
while not exit:
  menu.displayMenu()
  sleep(1)
  choice = menu.getChoice()
  sleep(2)
  exit = menu.handleChoice(choice)
  sleep(3)
  print("\n")
quit()

#Moai finds out he's broke (Unit test #4 - written by Adam)
isMoaiBroke = FinanceOptions()
currency = input("What is your currency symbol?: ")

gottaMakeMoola = True
while gottaMakeMoola == True:
  print(isMoaiBroke.SeeFinanceHistory())
  print("\n")
  income = int(input("Enter income (if no income is made, type '0'): "))
  isMoaiBroke.IncomeInput(income)
  expenses = int(input("Enter expenses (if no income is made, type '0'): "))
  isMoaiBroke.ExpensesInput(expenses)

  seeBalance = input("Would you like to see your current balance?")
  if seeBalance == "Yes" or seeBalance == "yes":
    balance = isMoaiBroke.TotalBalanceCalc()
    print("Your current balance is: " + str(currency) + str(balance))
  else:
    print("That's fine! Your balance is completely private and isn't shown!")

  seeIncome = input("Would you like to see your total income \n(Since you started your bank account) ")
  if seeIncome == "Yes" or seeIncome == "yes":
    totalIncome = isMoaiBroke.IncomeOutput()
    print("Your total income is: " + str(currency) + str(totalIncome))
  else:
    print("That's fine! Your income is completely private and isn't shown!")

  seeExpenses = input("Would you like to see your total expenses? \n(Since you started your bank account) ")
  if seeExpenses == "Yes" or seeExpenses == "yes":
    totalExpenses = isMoaiBroke.ExpensesOutput()
    print("Your total expenses are: " + str(currency) + str(totalExpenses))
  else:
     print("That's fine! Your expenses are completely private and isn't shown!")

  seeHistory = input("Would you like to see your finance history so far? \n(Since you started your bank account) ")
  if seeHistory == "Yes" or seeHistory == "yes":
    financeHistory = isMoaiBroke.SeeFinanceHistory()
    print("Here is your entire finance history: " + str(financeHistory))
  else:
     print("That's fine! Your history is completely private and isn't shown!")

  makeMoney = input("Do u still want to make money?: ")
  if makeMoney == "Yes" or makeMoney == "yes":
    gottaMakeMoola = True
  else:
    gottaMakeMoola = False

"""## Edits Log

- [x] Adam Shabbir at 01/10/2024 from ~16:00 to 16:28 - Making a class for accounts, which will contain account data. Just a general one for now, nothing unique yet.
- [x] Adam Shabbir at 01/10/2024 from 20:26 to 21:13 - Login function works, but a while loop or for loop needs to be implemented to allow for the user to try again.
- [x] Hasan Akhtar at 02/10/2024 from 07:06 to 07:13 - changed account reference to self to make specific to that object, added unit test for account in seperate cell, account still works and unit test good.
- [x] Adam Shabbir at 04/10/2024 from ~18:00 to 19:15 - Trying to make a test to allow for a limited number of logging in attempts. Also made some notes for myself on what I think should be developed.
- [x] Hasan Akhtar at 05/10/2024 from 16:36 to 18:15 - Making a class for storage and manipulation of all accounts (kinda like a mini database), updating Account class to include more essential methods, also adding Menu class to include interface methods of program. Added a unit test for each of these new additions. Features all fully working, just need minor improvements.
- [x] Adam Shabbir at 06/10/2024 from 15:20 to 16:40 - Added finance accounts class to track finances.
- [x] Hasan Akhtar at 06/10/2024 from 15:30 to 16:50 - Added admin account type and related methods, also added menu option 12 which allows and admin to add admin accounts, next need to add checks for admin permissions and new unit test, but this part now done.
- [x] Adam Shabbir at 09/10/2024 from 08:00 to 09:30 - Worked on the FinanceOptions class. The finance Options class is not completed.
- [x] Adam Shabbir at 11/10/2024 from 15:40 to 16:08 - Made minor fixes - Allowed the user to see their finance history, which shows their income and expenses. Finance options is still not completed, but significant progress made. Also wrote unit test for this, unit test shows that it is fully working at the moment.
- [x] Hasan Akhtar + Adam Shabbir at 12/10/2024 from 15:45 to 16:16 - Hasan added the options dictionary in the constructor method attributes. Also adjusted the SeeFinanceHistory method to make it more user-friendly. Adam added in the displayMenu and getChoice methods thereafter. Hasan also filled in financeOptions method of Menu class to reflect the changes to the FinanceOptions class.
- [x] Hasan Akhtar at 10/11/2024 from 09:30 to 10:30 - Added the Category class with its various methods. Also updated the Budgeting class to incorporate this new class.
- [x] Adam Shabbir at 10/11/2024 from 09:30 to 10:30 - Started work on the Reporting Class by adding in parameters and allowing dates to be convertedÂ intoÂ objects
- [x] Rayhaan Hussain at 10/11/2024 from 09:00 to 11:00 (noice) - Started work on the Transaction Notes class by allowing notes to be viewed, made and deleted
- [x] Hasan Akhtar at 01/12/2024 from 12:15 to 13:25 - Updated the Budgeting class to incorporate new Category class, final adjustments and added a progressCategory method to supplement this, also tested and all working as intended.
- [x] Adam Shabbir at 01/12/2024 from 12:15 to 13:15 - Made corrections to reporting class (forgot self ðŸ’€) and started to add a 2d array grid function that will add income and expensesÂ ofÂ eachÂ day
- [x] Rayhaan Hussain at 01/12/2024 from 12:15 to 13:15 - Added a 2nd array "transactions" and can now process transactions (viewing, adding, deleting).
- [x] Hasan Akhtar at 21/12/2024 from 20:35 to 22:15 - Adjusted Finance Options to account for Reporting and generating the report
- [x] Adam Shabbir at 24/12/2024 for 30 minutes and at 25/12/2024 from 17:30 to 19:35 - Completed setDate method for Reporting class, which generates IDs and pairs a newly generated ID with a transaction date passed into the method.
- [x] Hasan Akhtar at 29/12/2024 from 16:15 to 17:30 - Adjusted Transaction Notes to integrate with the rest of the code and reflect the recent changes in Finance Options, also updated Finance Options to complete the integration and ran unit tests
- [x] Adam Shabbir at 29/12/2024 from 16:30 to 17:30 - Literally tried to figure out how to generate what to generate. Didn't do anything substantial except for 5 lines.
"""